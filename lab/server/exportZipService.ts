import archiver from 'archiver'
import type { Response } from 'express'

type ExportFramework = 'react' | 'html'

type ExportComponentInput = {
  componentDir?: string
  source?: string
  htmlSource?: string
  cssSource?: string
  meta?: {
    name?: string
    dependencies?: string[]
  }
}

type ExportZipRequest = {
  components?: ExportComponentInput[]
  framework?: string
}

type ValidationResult =
  | { ok: true; framework: ExportFramework; components: ExportComponentInput[] }
  | { ok: false; status: number; message: string }

const EXPORT_VERSION = '1.0.0'

function slugify(value: string): string {
  return value
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .replace(/[^a-zA-Z0-9-]/g, '')
    .toLowerCase()
}

function pascalCase(value: string): string {
  return value
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .trim()
    .split(/\s+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('')
}

function stampBlock(framework: ExportFramework, fileComment: { start: string; end: string }, date: string): string {
  return `${fileComment.start}
 * Generated by UI Lab
 * Framework: ${framework === 'react' ? 'React' : 'HTML + CSS'}
 * Export Version: ${EXPORT_VERSION}
 * Date: ${date}
 ${fileComment.end}`
}

function validateRequest(body: ExportZipRequest): ValidationResult {
  if (!Array.isArray(body.components) || body.components.length === 0) {
    return { ok: false, status: 400, message: 'components must be a non-empty array' }
  }

  if (body.framework !== 'react' && body.framework !== 'html') {
    return { ok: false, status: 400, message: 'framework must be "react" or "html"' }
  }

  for (const [index, component] of body.components.entries()) {
    if (!component || typeof component !== 'object') {
      return { ok: false, status: 400, message: `component at index ${index} is invalid` }
    }
    if (!component.meta?.name || typeof component.meta.name !== 'string') {
      return { ok: false, status: 400, message: `component at index ${index} is missing meta.name` }
    }
    if (body.framework === 'react' && (!component.source || typeof component.source !== 'string')) {
      return { ok: false, status: 400, message: `component "${component.meta.name}" is missing source` }
    }
    if (body.framework === 'html' && (!component.htmlSource || typeof component.htmlSource !== 'string')) {
      return { ok: false, status: 400, message: `component "${component.meta.name}" is missing htmlSource` }
    }
  }

  return { ok: true, framework: body.framework, components: body.components }
}

function uniqueName(base: string, seen: Set<string>): string {
  let candidate = base
  let i = 2
  while (seen.has(candidate)) {
    candidate = `${base}${i}`
    i += 1
  }
  seen.add(candidate)
  return candidate
}

function buildReactReadme(componentFiles: string[], dependencyNames: string[]): string {
  const installLine = dependencyNames.length > 0 ? `npm install ${dependencyNames.join(' ')}` : 'No additional dependencies required.'
  const first = componentFiles[0]?.replace('.tsx', '') || 'Component'

  return `# UI Lab React Bundle

Framework: React
Export Version: ${EXPORT_VERSION}

## Components
${componentFiles.map((name) => `- ${name}`).join('\n')}

## Installation
\`\`\`bash
${installLine}
\`\`\`

## Usage
\`\`\`tsx
import ${first} from './components/${first}'

export default function App() {
  return <${first} />
}
\`\`\`
`
}

function buildHtmlReadme(componentDirs: string[]): string {
  return `# UI Lab HTML Bundle

Framework: HTML + CSS
Export Version: ${EXPORT_VERSION}

## Components
${componentDirs.map((name) => `- ${name}`).join('\n')}

## Usage
Open any component folder and include its \`styles.css\` in your page, then use the markup from \`index.html\`.
`
}

export function exportZipToResponse(body: ExportZipRequest, res: Response) {
  const validation = validateRequest(body)
  if (!validation.ok) {
    res.status(validation.status).json({ success: false, message: validation.message })
    return
  }

  const { framework, components } = validation
  const date = new Date().toISOString().slice(0, 10)
  const archive = archiver('zip', { zlib: { level: 9 } })

  res.setHeader('Content-Type', 'application/zip')
  res.setHeader('Content-Disposition', 'attachment; filename="ui-lab-bundle.zip"')

  archive.on('error', (err: Error) => {
    if (!res.headersSent) {
      res.status(500).json({ success: false, message: err.message })
    } else {
      res.end()
    }
  })

  archive.pipe(res)

  if (framework === 'react') {
    const seen = new Set<string>()
    const componentFiles: string[] = []
    const dependencySet = new Set<string>()

    for (const component of components) {
      const baseName = pascalCase(component.meta?.name || 'Component')
      const componentName = uniqueName(baseName, seen)
      componentFiles.push(`${componentName}.tsx`)
      for (const dep of component.meta?.dependencies || []) {
        if (dep && dep !== 'react' && dep !== 'react-dom') dependencySet.add(dep)
      }

      const stampedTsx = `${stampBlock('react', { start: '/**', end: ' */' }, date)}\n${component.source?.trim()}\n`
      archive.append(stampedTsx, { name: `ui-lab-bundle/components/${componentName}.tsx` })
    }

    const dependencyNames = Array.from(dependencySet).sort()
    const packageJson = {
      name: 'ui-lab-bundle',
      version: EXPORT_VERSION,
      private: true,
      generatedBy: 'UI Lab',
      generatedAt: date,
      peerDependencies: {
        react: '^18.0.0',
        'react-dom': '^18.0.0',
      },
      dependencies: Object.fromEntries(dependencyNames.map((dep) => [dep, 'latest'])),
    }

    const readme = `${stampBlock('react', { start: '<!--', end: '-->' }, date)}\n${buildReactReadme(componentFiles, dependencyNames)}`

    archive.append(JSON.stringify(packageJson, null, 2), { name: 'ui-lab-bundle/package.json' })
    archive.append(readme, { name: 'ui-lab-bundle/README.md' })
  } else {
    const seen = new Set<string>()
    const componentDirs: string[] = []

    for (const component of components) {
      const baseDir = slugify(component.meta?.name || 'component')
      const dirName = uniqueName(baseDir, seen)
      componentDirs.push(dirName)

      const html = `${stampBlock('html', { start: '<!--', end: '-->' }, date)}\n${component.htmlSource?.trim()}\n`
      const css = `${stampBlock('html', { start: '/*', end: ' */' }, date)}\n${(component.cssSource || '').trim()}\n`

      archive.append(html, { name: `ui-lab-bundle/components/${dirName}/index.html` })
      archive.append(css, { name: `ui-lab-bundle/components/${dirName}/styles.css` })
    }

    const readme = `${stampBlock('html', { start: '<!--', end: '-->' }, date)}\n${buildHtmlReadme(componentDirs)}`
    archive.append(readme, { name: 'ui-lab-bundle/README.md' })
  }

  void archive.finalize()
}
